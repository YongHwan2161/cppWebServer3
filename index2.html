<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Title</title>
    <!-- Font Awesome CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <style>
        #clock {
            color: green;
            display: inline-block;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 10px;
        }

        .form-style {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 400px;
            margin: 10px auto;
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            margin-bottom: 3px;
        }

        .form-group input {
            width: 90%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .form-actions {
            text-align: right;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        .btn.login {
            background-color: #007bff;
            color: white;
        }

        .btn.signup {
            background-color: #28a745;
            color: white;
            margin-left: 10px;
        }

        /* Extra styles for placeholders */
        ::placeholder {
            color: #bbb;
        }


        #filecontent {
            display: none;
        }

        #saveFileChanges {
            display: none;
        }

        #contents,
        #info {
            display: inline-block;
            max-width: 500px;
            overflow-wrap: break-word;
        }

        textarea {
            width: 40%;
            margin-bottom: 10px;
        }

        .button {
            background-color: #007bff;
            border: none;
            color: white;
            padding: 2px 10px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 11px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 1px;
        }

        .button:hover {
            background-color: #0056b3;
        }

        .home-button {
            display: inline-block;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 15px;
            text-align: center;
            line-height: 30px;
            text-decoration: none;
            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.5);
        }

        .home-button:hover {
            background-color: #0056b3;
        }

        canvas {
            width: 100vw;
            height: 100vh;
            display: none;
        }

        #canvas2 {
            position: absolute;
            display: none;
        }

        #ui {
            width: 200px;
        }

        .container {
            position: relative;
            z-index: 2;
        }

        #overlay {
            position: absolute;
            left: 0px;
            top: 0px;
            background-color: rgba(219, 217, 217, 0.76);
            color: rgb(10, 9, 9);
            font-family: monospace;
            padding: 1em;
            border-radius: 1em;
            border: 1px solid rgba(255, 0, 0, 0.425);
            /* text-shadow: 0px 0px 5px white, 0px 0px 5px white, 0px 0px 5px white, 0px 0px 5px white; */
        }

        #control-buttons {
            position: fixed;
            bottom: 20px;
            left: 10%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 10px;
            width: 120px;
            text-align: center;
            align-items: center;
            z-index: 1;
        }

        .direction-btn {
            width: 40px;
            height: 40px;
            font-size: 20px;
            border: none;
            border-radius: 50%;
            background-color: #007BFF;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            /* Improves responsiveness for touch by disabling double-tap zoom */
        }

        .direction-btn.forward {
            grid-column: 2 / 3;
            grid-row: 1 / 2;
        }

        .direction-btn.left {
            grid-column: 1 / 2;
            grid-row: 2 / 3;
        }

        .direction-btn.right {
            grid-column: 3 / 4;
            grid-row: 2 / 3;
        }

        .direction-btn.backward {
            grid-column: 2 / 3;
            grid-row: 3 / 4;
        }

        .LogInfo {
            padding: 0 5px;
            display: none;
            overflow: hidden;
            transition: max-height 0.2s ease-out;
            background-color: #f1f1f1;
            margin-top: 0;
        }

        .collapsible {
            background-color: #777;
            color: white;
            cursor: pointer;
            padding: 5px;
            width: 90%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 10px;
            margin-bottom: 0;
        }

        .collapsible:hover {
            background-color: #555;
        }
    </style>
</head>

<body onload="start()">
    <button id="toggleButton" onclick="toggleContainer()">Minimize</button>
    <div class="container">
        <div id="content" style="display: block;">
            <canvas id="canvas"></canvas>
            <div id="overlay">
                <a href="#" class="home-button" onclick="home()"><i class="fas fa-home"></i></a>
                <div id="clock"></div><br />
                <form id="loginForm" class="form-style">
                    <div class="form-group">
                        <label for="username">Username:</label>
                        <input type="text" id="username" name="username" placeholder="Enter your username" required>
                    </div>
                    <div class="form-group">
                        <label for="password">Password:</label>
                        <input type="password" id="password" name="password" placeholder="Enter your password" required>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn login">Login</button>
                        <button type="button" id="showSignUpForm" class="btn signup">Sign Up</button>
                    </div>
                </form>

                <form id="signupForm" class="form-style" action="/signup" method="POST"
                    onsubmit="return validatePassword()" style="display: none;">
                    <div class="form-group">
                        <label for="newUsername">Username:</label>
                        <input type="text" id="newUsername" name="username" placeholder="Choose a username" required>
                        <button type="button" id="checkDuplicate">Check Duplicate</button>
                        <span id="usernameValidationMessage"></span>
                    </div>
                    <div class="form-group">
                        <label for="email">Email:</label>
                        <input type="email" id="email" name="email" placeholder="Your email address" required>
                    </div>
                    <div class="form-group">
                        <label for="newPassword">Password:</label>
                        <input type="password" id="newPassword" name="password" placeholder="Create a password"
                            required>
                    </div>
                    <div class="form-group">
                        <label for="confirmPassword">Confirm Password:</label>
                        <input type="password" id="confirmPassword" placeholder="Confirm your password" required>
                    </div>
                    <div class="form-actions">
                        <button type="submit" class="btn signup" id="signupButton" disabled>Sign Up</button>
                    </div>
                </form>

                <div id="contents"></div><br />
                <textarea id="textinput" placeholder="Enter text..."></textarea><br />
                <button class="button" id="Button_Enter"
                    onclick="sendTextToServer(document.getElementById('textinput').value)">Enter</button>
                <button class="button" id="Button_Review" onclick="sendTextToServer('98')">Review</button>
                <button class="button" id="Button_Copy" onclick="sendTextToServer('98')">Copy</button>
                <button class="button" id="Button_Paste" onclick="sendTextToServer('98')">Paste</button>
                <button class="button" id="Button_Save" onclick="sendTextToServer('save')">Save</button><br />
                <p id="info2"></p>
                <p class="collapsible">Log</p>
                <p class="LogInfo" id="Log"> </p>
                <p class="collapsible">Info</p>
                <p class="LogInfo" id="info"> </p> <br />
                <textarea id="fileContent" rows="1"></textarea><br />
                <button id="saveFileChanges" onclick="saveFileChanges()">Save Changes</button>
                <div>coordinates: <span id="readout"></span></div>
                <canvas id="canvas2" width="150" height="150"></canvas>
                <p id="deviceInfo"></p>
            </div>
        </div>
    </div>
    <div id="control-buttons">
        <button id="moveForward" class="direction-btn forward">&#9650;</button>
        <button id="moveLeft" class="direction-btn left">&#9664;</button>
        <button id="moveRight" class="direction-btn right">&#9654;</button>
        <button id="moveBackward" class="direction-btn backward">&#9660;</button>
    </div>


    <!--
  for most samples webgl-utils only provides shader compiling/linking and
  canvas resizing because why clutter the examples with code that's the same in every sample.
  See https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html
  and https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
  for webgl-utils, m3, m4, and webgl-lessons-ui.
  -->
    <script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
    <script src="https://webgl2fundamentals.org/webgl/resources/twgl-full.min.js"></script>
    <script src="https://webgl2fundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gl-matrix@2.8.1/dist/gl-matrix-min.js"></script>
    <script src="https://webgl2fundamentals.org/webgl/resources/flattened-primitives.js"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <script>
        function toggleContainer() {
            var contentDiv = document.getElementById("content");
            var toggleBtn = document.getElementById("toggleButton");
            if (contentDiv.style.display === "none") {
                contentDiv.style.display = "block";
                toggleBtn.innerText = "Minimize";
            } else {
                contentDiv.style.display = "none";
                toggleBtn.innerText = "Restore";
            }
        }
        function detectDeviceType() {
            const ua = navigator.userAgent;
            if (/mobile/i.test(ua)) {
                return 'Mobile';
            } else if (/tablet|ipad/i.test(ua)) {
                return 'Tablet';
            } else {
                return 'Desktop';
            }
        }

        const deviceType = detectDeviceType();
        document.getElementById('deviceInfo').innerHTML = `접속한 디바이스 타입: ${deviceType}`;

        // import * as THREE from 'three';

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
        camera.position.y = 1;
        camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x111111); // Light grey background color
        renderer.shadowMap.enabled = true; // 그림자 맵 활성화
        document.body.appendChild(renderer.domElement);

        // 키 입력 및 마우스 상태 관리
        //let isDragging = false;
        let previousMouseX = 0, previousMouseY = 0;
        let rotationSpeed = 0.005;

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3); // Soft white light
        scene.add(ambientLight);

        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 1);
        directionalLight.castShadow = true; // 그림자 발생 설정
        directionalLight.shadow.mapSize.width = 1024; // 그림자 해상도
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        // 중력 및 운동 변수
        const gravity = -0.02; // 중력 상수
        let velocityY = 0; // y축 초기 속도
        let onGround = true; // 접지 확인

        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }
        // 키보드 이벤트 리스너
        const keys = {};
        const keyActions = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '];
        const directions = {
            'moveForward': 'ArrowUp',
            'moveBackward': 'ArrowDown',
            'moveLeft': 'ArrowLeft',
            'moveRight': 'ArrowRight'
        };

        function setKeyState(key, state) {
            if (keyActions.includes(key)) {
                event.preventDefault();
                keys[key] = state;
                if (key === ' ' && state === true && onGround) { //'Space' key is set as ' ';
                    console.log("key = " + key + ", state = " + state + ", onGround = " + onGround);
                    performJump();
                }
            }
        }

        function performJump() {
            camera.position.y = 2;
            velocityY = 0.4;
            onGround = false;
        }

        document.addEventListener('keydown', (event) => setKeyState(event.key, true));
        document.addEventListener('keyup', (event) => setKeyState(event.key, false));

        Object.entries(directions).forEach(([buttonId, keyName]) => {
            const button = document.getElementById(buttonId);
            button.addEventListener('touchstart', (event) => setKeyState(keyName, true));
            button.addEventListener('touchend', (event) => setKeyState(keyName, false));
        });

        // 마우스 이벤트 리스너
        let lastX, lastY, isDragging = false;

        function handleStart(x, y) {
            isDragging = true;
            lastX = x;
            lastY = y;
        }

        function handleMove(x, y) {
            if (!isDragging) return;
            const deltaX = x - lastX;
            const deltaY = y - lastY;
            camera.rotation.y -= deltaX * 0.005;
            camera.rotation.x -= deltaY * 0.005;
            lastX = x;
            lastY = y;
            camera.updateProjectionMatrix();
        }

        function handleEnd() {
            isDragging = false;
        }

        // 마우스 이벤트
        document.addEventListener('mousedown', (event) => {
            handleStart(event.clientX, event.clientY);
        });
        document.addEventListener('mousemove', (event) => {
            handleMove(event.clientX, event.clientY);
        });
        document.addEventListener('mouseup', handleEnd);

        // 터치 이벤트
        document.addEventListener('touchstart', (event) => {
            const touch = event.touches[0];
            handleStart(touch.clientX, touch.clientY);
        }, { passive: false });

        document.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            handleMove(touch.clientX, touch.clientY);
            event.preventDefault(); // 스크롤 방지
        }, { passive: false });

        document.addEventListener('touchend', handleEnd);


        // 충돌을 감지하는 함수
        function checkCollision(cameraPosition, direction, distance) {
            const raycaster = new THREE.Raycaster(cameraPosition, direction);
            const intersects = raycaster.intersectObjects(scene.children.filter(obj => obj !== gridHelper), true); // 격자를 제외한 모든 객체와 충돌 검사
            if (intersects.length > 0) {
                console.log(intersects[0].distance);
            }

            if (intersects.length > 0 && intersects[0].distance < distance) {
                // 충돌 발생
                return true;
            }

            // 충돌 없음
            return false;
        }

        // 카메라 이동 업데이트
        function updateCamera() {
            const speed = 0.1;
            const direction = new THREE.Vector3();

            // 현재 카메라의 방향을 기준으로 전진, 후진 벡터 계산
            camera.getWorldDirection(direction);

            // 새로운 카메라 위치 계산
            const newPosition = camera.position.clone();

            if (keys['ArrowUp']) newPosition.addScaledVector(direction, speed);
            if (keys['ArrowDown']) newPosition.addScaledVector(direction, -speed);

            // 좌우 이동을 위해 원래 벡터에 대해 오른쪽 방향으로 90도 회전
            var direction2 = direction;
            direction.crossVectors(camera.up, direction).normalize();
            var rightDirection = direction;
            if (keys['ArrowLeft']) newPosition.addScaledVector(direction, speed);
            if (keys['ArrowRight']) newPosition.addScaledVector(direction, -speed);

            // 충돌 검사
            const collisionDistance = 1; // 충돌을 감지할 거리
            const directionDifference = newPosition.clone().sub(camera.position);
            const forwardCollision = checkCollision(camera.position, directionDifference, collisionDistance);

            if (!forwardCollision) {
                // 충돌이 발생하지 않으면 카메라 위치 업데이트
                camera.position.copy(newPosition);
            }
            if (keys['Space'] && onGround) {
                velocityY = 0.4; // 점프 초기 속도 설정
                onGround = false; // 공중에 떠있음
            }

            camera.updateProjectionMatrix();
        }

        // Create a cube
        const cubeGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 }); // Green cube
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 1;
        cube.castShadow = true; // 그림자 생성 설정
        cube.receiveShadow = false;
        scene.add(cube);


        const textureLoader = new THREE.TextureLoader();
        // Create a floor
        // const floorTextureURL = 'https://img.freepik.com/free-photo/marble-texture-background_1048-9588.jpg?w=1060&t=st=1713152819~exp=1713153419~hmac=87fc42cfcc097765b166e1181a3474b0bd0afa27203ef1c9124160081d7b97b2'; // 여기에 실제 텍스처 링크를 입력하세요
        // // 텍스처 로드
        // const floorTexture = textureLoader.load(floorTextureURL);
        function createFloor(width, height, color, position) {
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = new THREE.MeshPhongMaterial({ color: color, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
            floor.position.copy(position);
            floor.receiveShadow = true;
            scene.add(floor);
        }
        // const floorGeometry = new THREE.PlaneGeometry(200, 200);
        // const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x887799, side: THREE.DoubleSide });
        // const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        // floor.rotation.x = -Math.PI / 2; // Rotate the plane to be horizontal
        // floor.position.y = 0; // Position the floor slightly below the cube
        // floor.receiveShadow = true;
        // scene.add(floor);
        createFloor(200, 200, 0x778899, new THREE.Vector3(0, 0, 0));
        createFloor(2, 20, 0x556677, new THREE.Vector3(1, 0.02, 0));

        // 격자 무늬를 추가할 GridHelper 생성
        const gridSize = 200; // 격자의 전체 크기
        const gridSpacing = 1; // 격자의 간격
        const gridHelper = new THREE.GridHelper(gridSize, gridSize / gridSpacing, 0x666666, 0x666666); // 첫 번째 매개변수는 전체 크기, 두 번째 매개변수는 격자 개수, 세 번째 매개변수는 격자 색상, 네 번째 매개변수는 선 색상
        gridHelper.position.y = 0.01; // 바닥 평면과 겹치지 않도록 약간 띄웁니다.
        scene.add(gridHelper);



        function createBox(width, height, depth, color, position) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const box = new THREE.Mesh(geometry, material);
            box.position.copy(position);
            scene.add(box);
        }
        // 첫 번째 직육면체 생성
        createBox(10, 4, 0.1, 0xeeeeee, new THREE.Vector3(-5, 2, -10));
        createBox(8, 4, 0.1, 0xeeeeee, new THREE.Vector3(6, 2, -10));
        createBox(20, 1, 0.1, 0xeeeeee, new THREE.Vector3(0, 4.5, -10));

        // 텍스처 링크
        const woodTextureURL = 'https://cdn.pixabay.com/photo/2017/02/07/09/02/wood-2045379_1280.jpg'; // 여기에 실제 텍스처 링크를 입력하세요
        // 텍스처 로드
        const woodTexture = textureLoader.load(woodTextureURL);
        // 문
        const doorGeometry = new THREE.BoxGeometry(2, 4, 0.1);
        const doorMaterial = new THREE.MeshBasicMaterial({ map: woodTexture });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.geometry.translate(1, 0, 0);
        door.position.set(0, 2, -10);
        // 문의 기하학적 중심을 하단 모서리로 이동
        scene.add(door);
        // 문 손잡이
        const handleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 32);
        const handleMaterial = new THREE.MeshBasicMaterial({ color: 0x8b4513 });
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.set(1.8, 0, 0);
        // 문에 손잡이를 붙이기
        door.add(handle);

        // 문의 초기 상태 설정
        let doorIsOpen = false;
        const doorOpenAngle = Math.PI / 2; // 문이 90도까지 열리도록 설정
        const doorSpeed = 0.03; // 문 열리는 속도

        // // 책장 생성 함수
        // function createBookshelf() {
        //     // 책장 전체 오브젝트
        //     const bookshelf = new THREE.Object3D();

        //     // 책장 바닥
        //     const shelfGeometry = new THREE.BoxGeometry(10, 1, 5);
        //     const shelfMaterial = new THREE.MeshBasicMaterial({ color: 0x663300 }); // 갈색
        //     const shelf = new THREE.Mesh(shelfGeometry, shelfMaterial);
        //     shelf.position.set(0, -0.5, 0);
        //     bookshelf.add(shelf);

        //     // 책장 세로 틀 (좌측)
        //     const verticalFrameGeometry = new THREE.BoxGeometry(1, 10, 1);
        //     const verticalFrame = new THREE.Mesh(verticalFrameGeometry, shelfMaterial);
        //     verticalFrame.position.set(-4.5, 4.5, 0);
        //     bookshelf.add(verticalFrame);

        //     // 책장 세로 틀 (우측)
        //     const verticalFrame2 = new THREE.Mesh(verticalFrameGeometry, shelfMaterial);
        //     verticalFrame2.position.set(4.5, 4.5, 0);
        //     bookshelf.add(verticalFrame2);

        //     // 책 생성 함수
        //     function createBook(position) {
        //         const bookGeometry = new THREE.BoxGeometry(1, 1, 2); // 책의 크기는 1x1x2로 가정
        //         const bookMaterial = new THREE.MeshBasicMaterial({ color: 0x3366ff }); // 파란색
        //         const book = new THREE.Mesh(bookGeometry, bookMaterial);
        //         book.position.copy(position);
        //         return book;
        //     }

        //     // 책장에 책을 배치
        //     const numBooksPerShelf = 4; // 각 책장마다 4권의 책을 배치하도록 설정
        //     const spacing = 2; // 책 간의 간격
        //     const shelfStartX = -3; // 책장의 시작 X 좌표
        //     const shelfStartY = 1; // 책장의 시작 Y 좌표
        //     const shelfStartZ = -1; // 책장의 시작 Z 좌표
        //     for (let i = 0; i < numBooksPerShelf; i++) {
        //         const bookX = shelfStartX + i * spacing;
        //         const bookY = shelfStartY;
        //         const bookZ = shelfStartZ;
        //         const book = createBook(new THREE.Vector3(bookX, bookY, bookZ));
        //         bookshelf.add(book);
        //     }

        //     return bookshelf;
        // }
        // // 책장 생성 및 scene에 추가
        // const bookshelf = createBookshelf();
        // scene.add(bookshelf);

        // 마우스 클릭 이벤트
        window.addEventListener('click', onMouseClick);
        // 마우스와 raycaster 설정
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();

        function onMouseClick(event) {
            // 마우스 위치 계산 (정규화)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            camera.updateProjectionMatrix();
            door.geometry.computeBoundingBox();

            // raycaster 업데이트
            raycaster.setFromCamera(mouse, camera);

            // 교차되는 객체 계산
            const intersects = raycaster.intersectObjects(scene.children, true);

            // 교차되는 객체가 있고, 문이라면 동작 실행
            for (let i = 0; i < intersects.length; i++) {
                if (intersects[i].object === door) {
                    console.log('문이 클릭되었습니다!');
                    // 여기에 원하는 추가 동작을 작성하세요
                    if (!doorIsOpen) {
                        openDoor();
                    } else {
                        closeDoor();
                    }
                }
            }
        }
        function openDoor() {
            if (door.rotation.y < doorOpenAngle) {
                door.rotation.y += doorSpeed;
                requestAnimationFrame(openDoor); // 계속해서 문을 열도록 재귀 호출
            } else {
                doorIsOpen = true; // 문이 완전히 열렸음을 표시
            }
        }

        function closeDoor() {
            if (door.rotation.y > 0) {
                door.rotation.y -= doorSpeed;
                requestAnimationFrame(closeDoor); // 계속해서 문을 닫도록 재귀 호출
            } else {
                doorIsOpen = false; // 문이 완전히 닫혔음을 표시
            }
        }
        var canvas2 = document.getElementById('canvas2'),
            context = canvas2.getContext('2d'),
            FONT_HEIGHT = 10,
            MARGIN = 25,
            HAND_TRUNCATION = canvas2.width / 25,
            HOUR_HAND_TRUNCATION = canvas2.width / 10,
            NUMERAL_SPACING = 10,
            RADIUS = canvas2.width / 2 - MARGIN,
            HAND_RADIUS = RADIUS + NUMERAL_SPACING;

        function drawCircle() {
            context.beginPath();
            context.arc(canvas2.width / 2, canvas2.height / 2, RADIUS, 0, Math.PI * 2, true);
            context.lineWidth = 5;
            context.strokeStyle = '#333';
            context.shadowBlur = 10;
            context.shadowColor = '#333';
            context.stroke();
        }

        function drawNumerals() {
            var numerals = ['III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI', 'XII', 'I', 'II'],
                angle = 0,
                numeralWidth = 0;
            numerals.forEach(function (numeral) {
                angle = Math.PI / 6 * (numerals.indexOf(numeral));
                numeralWidth = context.measureText(numeral).width;
                context.font = FONT_HEIGHT + 'px Arial';
                context.fillStyle = '#000000';
                context.fillText(numeral, canvas2.width / 2 + Math.cos(angle) * (HAND_RADIUS) - numeralWidth / 2, canvas2.height / 2 + Math.sin(angle) * (HAND_RADIUS) + FONT_HEIGHT / 3);
            });
        }

        function drawCenter() {
            context.beginPath();
            context.arc(canvas2.width / 2, canvas2.height / 2, 5, 0, Math.PI * 2, true);
            context.fillStyle = '#333';
            context.shadowBlur = 0;
            context.fill();
        }

        function drawHand(loc, isHour, thickness) {
            var angle = (Math.PI * 2) * (loc / 60) - Math.PI / 2,
                handRadius = isHour ? RADIUS - HAND_TRUNCATION - HOUR_HAND_TRUNCATION : RADIUS - HAND_TRUNCATION;
            context.beginPath();
            context.moveTo(canvas2.width / 2, canvas2.height / 2);
            context.lineTo(canvas2.width / 2 + Math.cos(angle) * handRadius, canvas2.height / 2 + Math.sin(angle) * handRadius);
            context.lineWidth = thickness;
            context.lineCap = "round";
            context.strokeStyle = '#000000';
            context.shadowBlur = 10;
            context.shadowColor = '#333';
            context.stroke();
        }

        function drawHands() {
            var date = new Date,
                hour = date.getHours();
            hour = hour > 12 ? hour - 12 : hour;
            drawHand(hour * 5 + (date.getMinutes() / 60) * 5, true, 8);
            drawHand(date.getMinutes(), false, 5);
            drawHand(date.getSeconds(), false, 2);
        }

        function drawClock() {
            context.clearRect(0, 0, canvas2.width, canvas2.height);
            context.fillStyle = '#dddddd';
            context.fillRect(0, 0, canvas2.width, canvas2.height);
            drawCircle();
            drawCenter();
            drawHands();
            drawNumerals();
        }

        setInterval(drawClock, 1000);

        const texture2 = new THREE.CanvasTexture(canvas2);

        // Create a plane and add it to the scene
        const planeGeometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.MeshBasicMaterial({ map: texture2, color: 0xffffff });
        const plane = new THREE.Mesh(planeGeometry, material);
        plane.position.x = -9;
        plane.position.y = 3;
        plane.position.z = -9.899;
        scene.add(plane);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            //drawClock();
            texture2.needsUpdate = true;
            // Rotate the cube
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            // 중력 효과 적용
            if (camera.position.y > 1) {
                velocityY += gravity;
                camera.position.y += velocityY;
                // if (camera.position.y <= 1) {
                //     camera.position.y = 1;
                //     velocityY = 0;
                //     onGround = true; // 다시 바닥에 도착
                // }
            } else if (camera.position.y <= 1) {
                camera.position.y = 1;
                velocityY = 0;
                onGround = true; // 다시 바닥에 도착
            }
            updateCamera();
            renderer.render(scene, camera);
        }

        animate();
    </script>

    <script>
        let user = 0, node = 0, ch = 0;
        function updateClock() {
            document.getElementById("clock").textContent = new Date().toLocaleTimeString();
        }

        function sendTextToServer(textinput) {
            //const textinput = document.getElementById("textinput").value;
            const fileContent = document.getElementById('fileContent').value;
            const additionalContent = textinput === "editHtml" ? `\t${fileContent}` : (textinput === "editcppl" ? `\t${fileContent}` : '');
            const text = `${user}\t${node}\t${ch}\t${textinput}${additionalContent}`;

            const xhr = new XMLHttpRequest();
            xhr.open('POST', 'https://obscure-space-train-v9xrjvg795p2rx5-8080.app.github.dev/', true);
            xhr.setRequestHeader('Content-Type', 'text/plain; charset=utf-8');
            xhr.onload = function () {
                if (xhr.status === 200) {
                    const res = xhr.responseText.split('\t');
                    updateUI(res);
                } else {
                    console.error('Error:', xhr.status, xhr.statusText);
                    document.getElementById("contents").textContent = `An error occurred: ${xhr.status} ${xhr.statusText}`;
                }
            };
            xhr.onerror = function () {
                console.error('Request failed.');
            };
            xhr.send(text);
        }
        function updateUI(res) {
            user = res[0];
            node = res[1];
            ch = res[2];
            const contents = document.getElementById("contents");
            const info = document.getElementById("info2");
            if (res[5] === "html") {
                document.getElementById('fileContent').value = res[3];
            } else if (res[5] === "cpp") {
                document.getElementById('fileContent').value = res[3];
            } else {
                contents.innerHTML = res[3];
            }
            info.innerHTML = `user: ${res[0]}, node: ${res[1]}/${res[4]}, ch: ${res[2]}<br> Last: ${res[6]}, Create: ${res[7]}`;
            document.getElementById("textinput").value = res[5];
            document.getElementById('Log').innerText = res[8];
            document.getElementById('info').innerText = res[9];
            console.log(res);
            if (document.getElementById("textinput").value == '98') {
                document.getElementById('Button_Review').focus();
                console.log('Review button clicked.');
            } else {
                document.getElementById("textinput").focus();
                console.log('focused on inputtext.');
            }
        }
        function saveFileChanges() {
            if (document.getElementById("textinput").value === "html") {
                document.getElementById("textinput").value = "editHtml";
            } else {
                document.getElementById("textinput").value = "editcpp";
            }
            sendTextToServer();
            //location.reload();
        }
        // 중복 확인 버튼 클릭 시 이벤트 핸들러 등록
        document.getElementById('checkDuplicate').addEventListener('click', function () {
            checkDuplicate();
        });
        function checkDuplicate() {
            var username = document.getElementById('newUsername').value;

            // AJAX 요청을 보내기 위한 XMLHttpRequest 객체 생성
            var xhr = new XMLHttpRequest();

            // 요청 완료 후 처리할 함수 등록
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    if (xhr.status === 200) {
                        // 요청이 성공하면 응답을 처리
                        var response = xhr.responseText;
                        if (response === "Username available") {
                            document.getElementById('usernameValidationMessage').innerText = "Username is available";
                            document.getElementById('signupButton').disabled = false; // 회원가입 버튼 활성화
                        } else {
                            document.getElementById('usernameValidationMessage').innerText = "Username is already taken";
                        }
                    } else {
                        // 요청이 실패하면 오류 메시지를 표시
                        console.error('Request failed: ', xhr.status);
                    }
                }
            };

            // 서버로 요청을 보냄
            xhr.open('GET', '/checkDuplicate?username=' + encodeURIComponent(username), true);
            xhr.send();
        }

        window.onload = function () {
            document.getElementById('Log').innerText = 'Page is fully loaded.';
            updateClock();
            setInterval(updateClock, 1000);
            sendTextToServer();
            document.getElementById('signupForm').style.display = 'none';
        }
        document.getElementById("loginForm").addEventListener("submit", function (event) {
            event.preventDefault(); // Prevent the form from submitting

            var formData = new FormData(this); // Collect form data

            fetch("/login", {
                method: "POST",
                body: formData
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.text();
                })
                .then(data => {
                    // Handle successful login response
                    const res = data.split('\t');
                    updateUI(res);
                    // Hide the login form
                    document.getElementById("loginForm").style.display = "none";
                    //console.log(data); // Do whatever processing you need with the response data
                })
                .catch(error => {
                    // Handle error
                    console.error('There was a problem with the fetch operation:', error);
                });
        });
        document.addEventListener('DOMContentLoaded', function () {
            document.getElementById('showSignUpForm').addEventListener('click', function () {
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('signupForm').style.display = 'block';
            });
            var coll = document.getElementsByClassName("collapsible");
            for (var i = 0; i < coll.length; i++) {
                coll[i].addEventListener("click", function () {
                    this.classList.toggle("active");
                    var content = this.nextElementSibling;
                    if (content.style.display === "block") {
                        content.style.display = "none";
                    } else {
                        content.style.display = "block";
                    }
                });
            }
        });

        function validatePassword() {
            var password = document.getElementById("newPassword").value;
            var confirmPassword = document.getElementById("confirmPassword").value;
            console.log(password + ", " + confirmPassword);
            if (password != confirmPassword) {
                alert("Passwords do not match.");
                return false;
            }
            return true;
        }
        function home() {
            const signupForm = document.getElementById('signupForm');
            if (signupForm.style.display == 'block') {
                document.getElementById('loginForm').style.display = 'block';
                signupForm.style.display = 'none';
            } else {
                sendTextToServer('start');
            }
        }
        /* eslint no-console:0 consistent-return:0 */
        'use strict';

        //         const vs = `#version 300 es
        // in vec4 a_position;
        // in vec2 a_texcoord;
        // in vec3 a_normal;

        // uniform mat4 u_projection;
        // uniform mat4 u_view;
        // uniform mat4 u_world;
        // uniform mat4 u_textureMatrix;

        // out vec2 v_texcoord;
        // out vec4 v_projectedTexcoord;
        // out vec3 v_normal;

        // void main() {
        //   // Multiply the position by the matrix.
        //   vec4 worldPosition = u_world * a_position;

        //   gl_Position = u_projection * u_view * worldPosition;

        //   // Pass the texture coord to the fragment shader.
        //   v_texcoord = a_texcoord;

        //   v_projectedTexcoord = u_textureMatrix * worldPosition;

        //   // orient the normals and pass to the fragment shader
        //   v_normal = mat3(u_world) * a_normal;
        // }
        // `;
        //         const fs = `#version 300 es
        // precision highp float;

        // // Passed in from the vertex shader.
        // in vec2 v_texcoord;
        // in vec4 v_projectedTexcoord;
        // in vec3 v_normal;

        // uniform vec4 u_colorMult;
        // uniform sampler2D u_texture;
        // uniform sampler2D u_projectedTexture;
        // uniform float u_bias;
        // uniform vec3 u_reverseLightDirection;

        // out vec4 outColor;

        // void main() {
        //   // because v_normal is a varying it's interpolated
        //   // so it will not be a unit vector. Normalizing it
        //   // will make it a unit vector again
        //   vec3 normal = normalize(v_normal);

        //   float light = dot(normal, u_reverseLightDirection);

        //   vec3 projectedTexcoord = v_projectedTexcoord.xyz / v_projectedTexcoord.w;
        //   float currentDepth = projectedTexcoord.z + u_bias;

        //   bool inRange =
        //       projectedTexcoord.x >= 0.0 &&
        //       projectedTexcoord.x <= 1.0 &&
        //       projectedTexcoord.y >= 0.0 &&
        //       projectedTexcoord.y <= 1.0;

        //   // the 'r' channel has the depth values
        //   float projectedDepth = texture(u_projectedTexture, projectedTexcoord.xy).r;
        //   float shadowLight = (inRange && projectedDepth <= currentDepth) ? 0.0 : 1.0;

        //   vec4 texColor = texture(u_texture, v_texcoord) * u_colorMult;
        //   outColor = vec4(
        //       texColor.rgb * light * shadowLight,
        //       texColor.a);
        // }
        // `;
        //         const colorVS = `#version 300 es
        // in vec4 a_position;

        // uniform mat4 u_projection;
        // uniform mat4 u_view;
        // uniform mat4 u_world;

        // void main() {
        //   // Multiply the position by the matrices.
        //   gl_Position = u_projection * u_view * u_world * a_position;
        // }
        // `;
        //         const colorFS = `#version 300 es
        // precision highp float;

        // uniform vec4 u_color;

        // out vec4 outColor;

        // void main() {
        //   outColor = u_color;
        // }
        // `;

        //         function main() {
        //             // Get A WebGL context
        //             /** @type {HTMLCanvasElement} */
        //             const canvas = document.querySelector('#canvas');
        //             const gl = canvas.getContext('webgl2');
        //             if (!gl) {
        //                 return;
        //             }

        //             // setup GLSL programs
        //             // note: Since we're going to use the same VAO with multiple
        //             // shader programs we need to make sure all programs use the
        //             // same attribute locations. There are 2 ways to do that.
        //             // (1) assign them in GLSL. (2) assign them by calling `gl.bindAttribLocation`
        //             // before linking. We're using method 2 as it's more. D.R.Y.
        //             const programOptions = {
        //                 attribLocations: {
        //                     'a_position': 0,
        //                     'a_normal': 1,
        //                     'a_texcoord': 2,
        //                     'a_color': 3,
        //                 },
        //             };
        //             const textureProgramInfo = twgl.createProgramInfo(gl, [vs, fs], programOptions);
        //             const colorProgramInfo = twgl.createProgramInfo(gl, [colorVS, colorFS], programOptions);

        //             // Tell the twgl to match position with a_position,
        //             // normal with a_normal etc..
        //             twgl.setAttributePrefix("a_");

        //             const sphereBufferInfo = flattenedPrimitives.createSphereBufferInfo(
        //                 gl,
        //                 1,  // radius
        //                 32, // subdivisions around
        //                 24, // subdivisions down
        //             );
        //             const planeBufferInfo = twgl.primitives.createPlaneBufferInfo(
        //                 gl,
        //                 40,  // width
        //                 40,  // height
        //                 1,   // subdivisions across
        //                 1,   // subdivisions down
        //             );
        //             const cubeBufferInfo = twgl.primitives.createCubeBufferInfo(gl, 2,);
        //             var coneBufferInfo = flattenedPrimitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 12, 1, true, false);
        //             const cubeLinesBufferInfo = twgl.createBufferInfoFromArrays(gl, {
        //                 position: [
        //                     -1, -1, -1,
        //                     1, -1, -1,
        //                     -1, 1, -1,
        //                     1, 1, -1,
        //                     -1, -1, 1,
        //                     1, -1, 1,
        //                     -1, 1, 1,
        //                     1, 1, 1,
        //                 ],
        //                 indices: [
        //                     0, 1,
        //                     1, 3,
        //                     3, 2,
        //                     2, 0,

        //                     4, 5,
        //                     5, 7,
        //                     7, 6,
        //                     6, 4,

        //                     0, 4,
        //                     1, 5,
        //                     3, 7,
        //                     2, 6,
        //                 ],
        //             });
        //             const wallBufferInfo = twgl.createBufferInfoFromArrays(gl, {
        //                 position: [
        //                     -10, 0, -10,  // v0
        //                     10, 0, -10,   // v1
        //                     10, 5, -10,    // v2
        //                     -10, 5, -10,   // v3
        //                     -10, 0, -11,   // v4
        //                     10, 0, -11,    // v5
        //                     10, 5, -11,     // v6
        //                     -10, 5, -11     // v7
        //                 ],
        //                 indices: [
        //                     0, 1, 2, 0, 2, 3,  // 앞면 (v0-v1-v2, v0-v2-v3)
        //                     1, 5, 6, 1, 6, 2,  // 오른쪽면 (v1-v5-v6, v1-v6-v2)
        //                     5, 4, 7, 5, 7, 6,  // 뒷면 (v5-v4-v7, v5-v7-v6)
        //                     4, 0, 3, 4, 3, 7,  // 왼쪽면 (v4-v0-v3, v4-v3-v7)
        //                     3, 2, 6, 3, 6, 7,  // 윗면 (v3-v2-v6, v3-v6-v7)
        //                     4, 5, 1, 4, 1, 0   // 밑면 (v4-v5-v1, v4-v1-v0)
        //                 ],
        //             });
        //             const canvas2BufferInfo = twgl.createBufferInfoFromArrays(gl, {
        //                 position: [
        //                     -10, 0, -10,  // v0
        //                     -5, 0, -10,   // v1
        //                     -5, 5, -10,    // v2
        //                     -10, 5, -10,   // v3
        //                 ],
        //                 indices: [
        //                     0, 1, 2, 0, 2, 3,  // 앞면 (v0-v1-v2, v0-v2-v3)
        //                 ],
        //             });

        //             const sphereVAO = twgl.createVAOFromBufferInfo(gl, textureProgramInfo, sphereBufferInfo);
        //             const planeVAO = twgl.createVAOFromBufferInfo(gl, textureProgramInfo, planeBufferInfo);
        //             const cubeVAO = twgl.createVAOFromBufferInfo(gl, textureProgramInfo, cubeBufferInfo);
        //             var coneVAO = twgl.createVAOFromBufferInfo(gl, textureProgramInfo, coneBufferInfo);
        //             const wallVAO = twgl.createVAOFromBufferInfo(gl, textureProgramInfo, wallBufferInfo);
        //             const canvas2VAO = twgl.createVAOFromBufferInfo(gl, textureProgramInfo, canvas2BufferInfo);

        //             const cubeLinesVAO = twgl.createVAOFromBufferInfo(gl, colorProgramInfo, cubeLinesBufferInfo);
        //             // make a 8x8 checkerboard texture
        //             const checkerboardTexture = gl.createTexture();
        //             gl.bindTexture(gl.TEXTURE_2D, checkerboardTexture);
        //             gl.texImage2D(
        //                 gl.TEXTURE_2D,
        //                 0,                // mip level
        //                 gl.LUMINANCE,     // internal format
        //                 8,                // width
        //                 8,                // height
        //                 0,                // border
        //                 gl.LUMINANCE,     // format
        //                 gl.UNSIGNED_BYTE, // type
        //                 new Uint8Array([  // data
        //                     0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        //                     0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        //                     0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        //                     0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        //                     0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        //                     0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        //                     0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC,
        //                     0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF, 0xCC, 0xFF,
        //                 ]));
        //             gl.generateMipmap(gl.TEXTURE_2D);
        //             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        //             // // 캔버스 요소에서 이미지 데이터 가져오기
        //             // canvas2.getContext('2d').willReadFrequently = true;
        //             // var imageData = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height);
        //             // var canvas2Texture = gl.createTexture();
        //             // gl.bindTexture(gl.TEXTURE_2D, canvas2Texture);

        //             var canvas2Texture = gl.createTexture();
        //             // 이미지 데이터를 WebGL 텍스처로 업로드
        //             // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
        //             // // Set the parameters so we don't need mips and so we're not filtering
        //             // // and we don't repeat at the edges
        //             // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //             // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        //             // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //             // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        //             // Set up the canvas and its texture
        //             const myCanvas = document.getElementById('myCanvas');
        //             myCanvas.width = 256;
        //             myCanvas.height = 256;
        //             const myCtx = myCanvas.getContext('2d');

        //             let hue = 0;
        //             function updateCanvas() {
        //                 hue = (hue + 1) % 360;
        //                 myCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        //                 myCtx.fillRect(0, 0, myCanvas.width, myCanvas.height);
        //             }
        //             const textureMy = new THREE.CanvasTexture(myCanvas);

        //             const depthTexture = gl.createTexture();
        //             const depthTextureSize = 1024;
        //             gl.bindTexture(gl.TEXTURE_2D, depthTexture);
        //             gl.texImage2D(
        //                 gl.TEXTURE_2D,      // target
        //                 0,                  // mip level
        //                 gl.DEPTH_COMPONENT32F, // internal format
        //                 depthTextureSize,   // width
        //                 depthTextureSize,   // height
        //                 0,                  // border
        //                 gl.DEPTH_COMPONENT, // format
        //                 gl.FLOAT,           // type
        //                 null);              // data
        //             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        //             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        //             const depthFramebuffer = gl.createFramebuffer();
        //             gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
        //             gl.framebufferTexture2D(
        //                 gl.FRAMEBUFFER,       // target
        //                 gl.DEPTH_ATTACHMENT,  // attachment point
        //                 gl.TEXTURE_2D,        // texture target
        //                 depthTexture,         // texture
        //                 0);                   // mip level

        //             function degToRad(d) {
        //                 return d * Math.PI / 180;
        //             }

        //             // Compute the camera's matrix using look at.
        //             var cameraPosition = [6, 6, 20];
        //             var cameraToX = 6;
        //             var cameraToY = 6;
        //             var cameraToZ = 20 - 1;
        //             var cameraDirection = [0, 0, -1];
        //             let yaw = -90.0; // Yaw is initialized to -90.0 degrees since a yaw of 0.0 results in a direction vector pointing to the right
        //             let pitch = 0.0;
        //             let lastX = canvas.width / 2, lastY = canvas.height / 2;
        //             let isDragging = false;
        //             const up = [0, 1, 0];
        //             // 카메라 오른쪽 벡터 (cameraDirection과 up 벡터를 외적하여 계산)
        //             var cameraRight = m4.cross(cameraDirection, up);

        //             const settings = {
        //                 posX: 2.5,
        //                 posY: 40,
        //                 posZ: 7,
        //                 targetX: 3.5,
        //                 targetY: 0,
        //                 targetZ: 3.5,
        //                 projWidth: 40,
        //                 projHeight: 40,
        //                 perspective: false,
        //                 fieldOfView: 120,
        //                 bias: -0.006,
        //             };
        //             function updateCameraDirection(x, y) {
        //                 const sensitivity = 0.5; // Change this value to make it more or less sensitive
        //                 const xOffset = (x - lastX) * sensitivity;
        //                 const yOffset = (lastY - y) * sensitivity; // Reversed since y-coordinates range from bottom to top

        //                 lastX = x;
        //                 lastY = y;

        //                 yaw += xOffset;
        //                 pitch += yOffset;

        //                 // Constrain the pitch so the screen doesn't flip
        //                 pitch = Math.max(-89.0, Math.min(89.0, pitch));

        //                 // Calculate the new Front vector
        //                 cameraDirection[0] = Math.cos(degToRad(yaw)) * Math.cos(degToRad(pitch));
        //                 cameraDirection[1] = Math.sin(degToRad(pitch));
        //                 cameraDirection[2] = Math.sin(degToRad(yaw)) * Math.cos(degToRad(pitch));
        //                 cameraDirection = m4.normalize(cameraDirection);
        //             }
        //             // 카메라 속도 (초당 이동 거리)
        //             const cameraSpeed = 0.2;
        //             // 카메라 방향 벡터 정규화
        //             var normalizedCameraDirection = m4.normalize(cameraDirection);

        //             // 이동 벡터 계산
        //             const moveVector = [0, 0, 0];
        //             // 키보드 이벤트 리스너 등록
        //             document.addEventListener('keydown', function (event) {
        //                 switch (event.key) {
        //                     case 'ArrowUp':
        //                         cameraPosition[0] += normalizedCameraDirection[0] * cameraSpeed;
        //                         cameraPosition[1] += normalizedCameraDirection[1] * cameraSpeed;
        //                         cameraPosition[2] += normalizedCameraDirection[2] * cameraSpeed;
        //                         break;
        //                     case 'ArrowDown':
        //                         cameraPosition[0] -= normalizedCameraDirection[0] * cameraSpeed;
        //                         cameraPosition[1] -= normalizedCameraDirection[1] * cameraSpeed;
        //                         cameraPosition[2] -= normalizedCameraDirection[2] * cameraSpeed;
        //                         break;
        //                     case 'ArrowLeft':
        //                         cameraPosition[0] -= cameraRight[0] * cameraSpeed;
        //                         cameraPosition[1] -= cameraRight[1] * cameraSpeed;
        //                         cameraPosition[2] -= cameraRight[2] * cameraSpeed;
        //                         break;
        //                     case 'ArrowRight':
        //                         cameraPosition[0] += cameraRight[0] * cameraSpeed;
        //                         cameraPosition[1] += cameraRight[1] * cameraSpeed;
        //                         cameraPosition[2] += cameraRight[2] * cameraSpeed;
        //                         break;
        //                 }
        //                 console.log(`Updated Camera Position: X=${cameraPosition[0]}, Z=${cameraPosition[2]}`);
        //             });
        //             canvas.addEventListener('mousedown', function (e) {
        //                 isDragging = true;
        //                 lastX = e.clientX;
        //                 lastY = e.clientY;
        //             });
        //             canvas.addEventListener('mouseup', function (e) {
        //                 isDragging = false;
        //             });
        //             document.addEventListener('mouseup', function (e) {
        //                 isDragging = false;
        //             });
        //             canvas.addEventListener('mousemove', function (e) {
        //                 var loc = windowToCanvas(canvas, e.clientX, e.clientY);
        //                 document.getElementById('readout').innerText = '(' + loc.x.toFixed(0) + ', ' + loc.y.toFixed(0) + ')';
        //                 if (isDragging) {
        //                     updateCameraDirection(e.clientX, e.clientY);
        //                 }
        //             });
        //             webglLessonsUI.setupUI(document.querySelector('#ui'), settings, [
        //                 // { type: 'slider', key: 'cameraX', min: -10, max: 10, change: render, precision: 2, step: 0.001, },
        //                 // { type: 'slider', key: 'cameraY', min: 1, max: 20, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'posX', min: -10, max: 10, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'posY', min: 1, max: 20, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'posZ', min: 1, max: 20, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'targetX', min: -10, max: 10, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'targetY', min: 0, max: 20, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'targetZ', min: -10, max: 20, change: render, precision: 2, step: 0.001, },
        //                 { type: 'slider', key: 'projWidth', min: 0, max: 200, change: render, precision: 4, step: 0.002, },
        //                 { type: 'slider', key: 'projHeight', min: 0, max: 200, change: render, precision: 4, step: 0.002, },
        //                 { type: 'checkbox', key: 'perspective', change: render, },
        //                 { type: 'slider', key: 'fieldOfView', min: 1, max: 179, change: render, },
        //                 { type: 'slider', key: 'bias', min: -0.01, max: 0.00001, change: render, precision: 4, step: 0.0001, },
        //             ]);

        //             const fieldOfViewRadians = degToRad(60);

        //             // Uniforms for each object.
        //             const planeUniforms = {
        //                 u_colorMult: [0.5, 0.5, 1, 1],  // lightblue
        //                 u_color: [1, 0, 0, 1],
        //                 u_texture: checkerboardTexture,
        //                 u_world: m4.translation(0, 0, 0),
        //             };
        //             const sphereUniforms = {
        //                 u_colorMult: [1, 0.5, 0.5, 1],  // pink
        //                 u_color: [0, 0, 1, 1],
        //                 u_texture: checkerboardTexture,
        //                 u_world: m4.translation(2, 3, 4),
        //             };
        //             const cubeUniforms = {
        //                 u_colorMult: [0.5, 1, 0.2, 0.9],  // lightgreen
        //                 u_color: [0, 0, 1, 1],
        //                 u_texture: checkerboardTexture,
        //                 u_world: m4.translation(3, 1, 0),
        //             };
        //             var coneUniforms = {
        //                 u_colorMult: [0.5, 1, 0.2, 0.9],  // lightgreen
        //                 u_color: [1, 0, 1, 1],
        //                 //u_texture: checkerboardTexture,
        //                 u_world: m4.translation(3, 0, 5),
        //             };
        //             var wallUniforms = {
        //                 u_colorMult: [0.5, 1, 0.2, 0.5],  // lightgreen
        //                 u_color: [0, 0.5, 1, 1],
        //                 u_texture: checkerboardTexture,
        //                 u_world: m4.translation(0, 0, 0),
        //             };
        //             var canvas2Uniforms = {
        //                 u_colorMult: [0.5, 1, 0.2, 0.5],  // lightgreen
        //                 u_color: [0, 0.5, 1, 1],
        //                 u_texture: textureMy,
        //                 u_world: m4.translation(0, 0, 2),
        //             };
        //             var objectsToDraw = [
        //                 {
        //                     programInfo: textureProgramInfo,
        //                     bufferInfo: planeBufferInfo,
        //                     vertexArray: planeVAO,
        //                     uniforms: planeUniforms,
        //                 },
        //                 {
        //                     programInfo: textureProgramInfo,
        //                     bufferInfo: sphereBufferInfo,
        //                     vertexArray: sphereVAO,
        //                     uniforms: sphereUniforms,
        //                 },
        //                 {
        //                     programInfo: textureProgramInfo,
        //                     bufferInfo: cubeBufferInfo,
        //                     vertexArray: cubeVAO,
        //                     uniforms: cubeUniforms,
        //                 },
        //                 {
        //                     programInfo: textureProgramInfo,
        //                     bufferInfo: coneBufferInfo,
        //                     vertexArray: coneVAO,
        //                     uniforms: coneUniforms,
        //                 },
        //                 {
        //                     programInfo: textureProgramInfo,
        //                     bufferInfo: wallBufferInfo,
        //                     vertexArray: wallVAO,
        //                     uniforms: wallUniforms,
        //                 },
        //                 {
        //                     programInfo: textureProgramInfo,
        //                     bufferInfo: canvas2BufferInfo,
        //                     vertexArray: canvas2VAO,
        //                     uniforms: canvas2Uniforms,
        //                 },
        //             ];
        //             function drawScene(
        //                 projectionMatrix,
        //                 cameraMatrix,
        //                 textureMatrix,
        //                 lightWorldMatrix,
        //                 programInfo) {
        //                 // Make a view matrix from the camera matrix.
        //                 const viewMatrix = m4.inverse(cameraMatrix);

        //                 gl.useProgram(programInfo.program);

        //                 // set uniforms that are the same for both the sphere and plane
        //                 // note: any values with no corresponding uniform in the shader
        //                 // are ignored.
        //                 twgl.setUniforms(programInfo, {
        //                     u_view: viewMatrix,
        //                     u_projection: projectionMatrix,
        //                     u_bias: settings.bias,
        //                     u_textureMatrix: textureMatrix,
        //                     u_projectedTexture: depthTexture,
        //                     u_reverseLightDirection: lightWorldMatrix.slice(8, 11),
        //                 });
        //                 objectsToDraw.forEach(function (object) {
        //                     // Setup all the needed attributes.
        //                     gl.bindVertexArray(object.vertexArray);
        //                     twgl.setUniforms(programInfo, object.uniforms);
        //                     twgl.drawBufferInfo(gl, object.bufferInfo);
        //                 });
        //             }

        //             // Draw the scene.
        //             function render() {
        //                 twgl.resizeCanvasToDisplaySize(gl.canvas);

        //                 gl.enable(gl.CULL_FACE);
        //                 gl.enable(gl.DEPTH_TEST);

        //                 // first draw from the POV of the light
        //                 const lightWorldMatrix = m4.lookAt(
        //                     [settings.posX, settings.posY, settings.posZ],          // position
        //                     [settings.targetX, settings.targetY, settings.targetZ], // target
        //                     [0, 1, 0],                                              // up
        //                 );
        //                 const lightProjectionMatrix = settings.perspective
        //                     ? m4.perspective(
        //                         degToRad(settings.fieldOfView),
        //                         settings.projWidth / settings.projHeight,
        //                         0.5,  // near
        //                         100)   // far
        //                     : m4.orthographic(
        //                         -settings.projWidth / 2,   // left
        //                         settings.projWidth / 2,   // right
        //                         -settings.projHeight / 2,  // bottom
        //                         settings.projHeight / 2,  // top
        //                         0.5,                      // near
        //                         100);                      // far

        //                 // draw to the depth texture
        //                 gl.bindFramebuffer(gl.FRAMEBUFFER, depthFramebuffer);
        //                 gl.viewport(0, 0, depthTextureSize, depthTextureSize);
        //                 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //                 drawScene(
        //                     lightProjectionMatrix,
        //                     lightWorldMatrix,
        //                     m4.identity(),
        //                     lightWorldMatrix,
        //                     colorProgramInfo);

        //                 // now draw scene to the canvas projecting the depth texture into the scene
        //                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        //                 gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        //                 gl.clearColor(0, 0, 0, 1);
        //                 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //                 let textureMatrix = m4.identity();
        //                 textureMatrix = m4.translate(textureMatrix, 0.5, 0.5, 0.5);
        //                 textureMatrix = m4.scale(textureMatrix, 0.5, 0.5, 0.5);
        //                 textureMatrix = m4.multiply(textureMatrix, lightProjectionMatrix);
        //                 // use the inverse of this world matrix to make
        //                 // a matrix that will transform other positions
        //                 // to be relative this this world space.
        //                 textureMatrix = m4.multiply(
        //                     textureMatrix,
        //                     m4.inverse(lightWorldMatrix));

        //                 // 정사각형의 각 모서리에 otherCanvas 매핑을 위한 texture matrix 설정
        //                 let canvas2textureMatrix = m4.identity();
        //                 canvas2textureMatrix = m4.translate(canvas2textureMatrix, -0.5, -0.5, 0); // 좌하단으로 이동
        //                 canvas2textureMatrix = m4.scale(canvas2textureMatrix, 0.5, 0.5, 1); // 크기 조정

        //                 // Compute the projection matrix
        //                 const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
        //                 const projectionMatrix =
        //                     m4.perspective(fieldOfViewRadians, aspect, 1, 2000);
        //                 //const target = cameraPosition + cameraDirection;
        //                 //const cameraMatrix = m4.lookAt(cameraPosition, target, up);
        //                 cameraRight = m4.cross(cameraDirection, up);
        //                 // 카메라 정규화 벡터 (cameraDirection 벡터의 길이를 1로 만듬)
        //                 normalizedCameraDirection = m4.normalize(cameraDirection);
        //                 // cameraMatrix 계산
        //                 const cameraMatrix = m4.lookAt(cameraPosition,
        //                     [cameraPosition[0] + normalizedCameraDirection[0],
        //                     cameraPosition[1] + normalizedCameraDirection[1],
        //                     cameraPosition[2] + normalizedCameraDirection[2]],
        //                     up);

        //                 // 캔버스 요소에서 이미지 데이터 가져오기
        //                 //const canvas2Test = document.getElementById('loginForm');
        //                 // var imageData = canvas2.getContext('2d').getImageData(0, 0, canvas2.width, canvas2.height);
        //                 // gl.bindTexture(gl.TEXTURE_2D, canvas2Texture);
        //                 // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, myCanvas);
        //                 // // Set the parameters so we don't need mips and so we're not filtering
        //                 // // and we don't repeat at the edges
        //                 // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        //                 // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        //                 updateCanvas();

        //                 drawScene(
        //                     projectionMatrix,
        //                     cameraMatrix,
        //                     textureMatrix,
        //                     lightWorldMatrix,
        //                     textureProgramInfo);
        //                 {

        //                 }
        //                 // ------ Draw the frustum ------
        //                 {
        //                     const viewMatrix = m4.inverse(cameraMatrix);

        //                     gl.useProgram(colorProgramInfo.program);

        //                     // Setup all the needed attributes.
        //                     gl.bindVertexArray(cubeLinesVAO);

        //                     // scale the cube in Z so it's really long
        //                     // to represent the texture is being projected to
        //                     // infinity
        //                     const mat = m4.multiply(
        //                         lightWorldMatrix, m4.inverse(lightProjectionMatrix));

        //                     // Set the uniforms we just computed
        //                     twgl.setUniforms(colorProgramInfo, {
        //                         u_color: [1, 1, 1, 1],
        //                         u_view: viewMatrix,
        //                         u_projection: projectionMatrix,
        //                         u_world: mat,
        //                     });

        //                     // calls gl.drawArrays or gl.drawElements
        //                     twgl.drawBufferInfo(gl, cubeLinesBufferInfo, gl.LINES);
        //                 }

        //                 const canvasTest = document.getElementById('canvasTest');
        //                 const contextTest = canvasTest.getContext('2d');

        //                 // 이미지 데이터를 캔버스에 그리기
        //                 //contextTest.putImageData(imageData, 0, 0);

        //                 requestAnimationFrame(render);
        //             }
        //             render();
        //         }

        //         main();


    </script>

    <script>
        var ws; // WebSocket 객체를 전역으로 선언

        function initWebSocket() {
            // WebSocket 서버의 URL. ws 또는 wss (SSL/TLS) 프로토콜을 사용할 수 있습니다.
            ws = new WebSocket('wss://obscure-space-train-v9xrjvg795p2rx5-8081.app.github.dev/');

            ws.onopen = function () {
                console.log('Connection opened!');
                sendMessage('Hello Server!');
            };

            ws.onmessage = function (event) {
                console.log('Received message: ' + event.data);
                displayMessage(event.data);
            };

            ws.onerror = function (error) {
                console.log('WebSocket Error: ' + error);
            };

            ws.onclose = function (event) {
                console.log('Connection closed. Code: ' + event.code + ', Reason: ' + event.reason);
            };
        }

        function sendMessage(message) {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(message);
                console.log('Sent message: ' + message);
            } else {
                console.log('WebSocket is not open. ReadyState: ' + ws.readyState);
            }
        }

        function displayMessage(message) {
            var messageContainer = document.getElementById('messages');
            var msgElement = document.createElement('p');
            msgElement.textContent = message;
            messageContainer.appendChild(msgElement);
        }

        window.onload = initWebSocket; // 페이지 로드 시 WebSocket 초기화
    </script>
</body>

</html>